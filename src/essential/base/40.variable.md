---
date: 2022-08-13
---
# 变量

变量是用于保存一个值的存储位置，允许其存储的值在运行时动态的变化。每声明一个变量，都会为其分配一块内存以存储对应类型的值，前往[参考手册-变量](https://go.dev/ref/spec#Variables)以查看更多细节。

<br>

## 声明

在go中的类型声明是后置的，变量的声明会用到`var`关键字，格式为`var 变量名 类型名`，变量名的命名规则必须遵守标识符的命名规则。

```go
var intNum int
var str string
var char byte
```

当要声明多个相同类型的变量时，可以只写一次类型

```go
var numA, numB, numC int
```

当要声明多个不同类型的变量时，可以使用`()`进行包裹，可以存在多个`()`。

```go
var (
	name    string
	age     int
	address string
)

var (
	school string
	class int
) 
```

一个变量如果只是声明而不赋值，那么变量存储的值就是对应类型的零值。

<br>

## 赋值

赋值会用到运算符`=`，例如

```go
var name string
name = "jack"
```

也可以声明的时候直接赋值

```go
var name string = "jack"
```

或者这样也可以

```go
var name string
var age int
name, age = "jack", 1
```

第二种方式每次都要指定类型，可以使用官方提供的语法糖：短变量初始化，可以省略掉`var`关键字和后置类型，具体是什么类型交给编译器自行推断。

```go
name := "jack" // 字符串类型的变量。
```

虽然可以不用指定类型，但是在后续赋值时，类型必须保持一致，下面这种代码无法通过编译。

```
a := 1
a = "1"
```

还需要注意的是，短变量初始化不能使用`nil`，因为`nil`不属于任何类型，编译器无法推断其类型。

```go
name := nil // 无法通过编译
```

短变量声明可以批量初始化

```go
name, age := "jack", 1
```

短变量声明方式无法对一个已存在的变量使用，比如

```go
// 错误示例
var a int
a := 1

// 错误示例
a := 1
a := 2
```

但是有一种情况除外，那就是在赋值旧变量的同时声明一个新的变量，比如

```go
a := 1
a, b := 2, 2
```

这种代码是可以通过编译的，变量`a`被重新赋值，而`b`是新声明的。

<br>

在go语言中，有一个规则，那就是所有在函数中的变量都必须要被使用，比如下面的代码只是声明了变量，但没有使用它

```go
func main() {
	a := 1
}
```

那么在编译时就会报错，提示你这个变量声明了但没有使用

```
a declared and not used
```

这个规则仅适用于函数内的变量，对于函数外的包级变量则没有这个限制，下面这个代码就可以通过编译。

```go
var a = 1

func main() {
	
}
```



## 交换

在Go中，如果想要交换两个变量的值，不需要使用指针，可以使用赋值运算符直接进行交换，语法上看起来非常直观，例子如下

```go
num1, num2 := 25, 36
num1, num2 = num2, num1
```

三个变量也是同样如此

```go
num1, num2, num3 := 25, 36, 49
num1, num2, num3  = num3, num2, num1
```

<br>

由于在函数内部存在未使用的变量会无法通过编译，但有些变量又确实用不到，这个时候就可以使用匿名变量`_`，使用`_`来表示该变量可以忽略，例如

```go
a, b, _ := 1, 2, 3
```



## 比较

变量之间的比较有一个大前提，那就是它们之间的类型必须相同，go语言中不存在隐式类型转换，像下面这样的代码是无法通过编译的

```
func main() {
	var a uint64
	var b int64
	fmt.Println(a == b)
}
```

编译器会告诉你两者之间类型并不相同

```
invalid operation: a == b (mismatched types uint64 and int64)
```

所以必须使用强制类型转换

```go
func main() {
	var a uint64
	var b int64
	fmt.Println(int64(a) == b)
}
```

在没有泛型之前，早期go提供的内置`min`，`max`函数只支持浮点数，到了1.21版本，go才终于将这两个内置函数用泛型重写。使用`min`函数比较最小值

```go
minVal := min(1, 2, -1, 1.2)
```

使用`max`函数比较最大值

```go
maxVal := max(100, 22, -1, 1.12)
```

它们的参数支持所有的可比较类型，go中的可比较类型有

- 布尔
- 数字
- 字符串
- 指针
- 通道 （仅支持判断是否相等）
- 元素是可比较类型的数组（切片不可比较）
- 字段类型都是可比较类型的结构体（仅支持判断是否相等）

除此之外，还可以通过导入标准库`cmp`来判断，不过仅支持有序类型的参数，在go中内置的有序类型只有数字和字符串。

```go
import "cmp"

func main() {
	cmp.Compare(1, 2)
	cmp.Less(1, 2)
}
```



## 代码块

在函数内部，可以通过花括号建立一个代码块，代码块彼此之间的变量作用域是相互独立的。例如下面的代码

```go
func main() {
	a := 1
	
	{
		a := 2
		fmt.Println(a)
	}
	
	{
		a := 3
		fmt.Println(a)
	}
	fmt.Println(a)
}
```

它的输出是

```
2
3
1
```

块与块之间的变量相互独立，不受干扰，无法访问，但是会受到父块中的影响。

```go
func main() {
	a := 1

	{
		a := 2
		fmt.Println(a)
	}

	{
		fmt.Println(a)
	}
	fmt.Println(a)
}
```

它的输出是

```
2
1
1
```

